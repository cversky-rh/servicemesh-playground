= Securing Access to Deployments in the ServiceMesh with TLS
:toc:

== Setup `SIMPLE TLS` Authentication for a Service Mesh included service


1. Create Service Mesh & a Service in the mesh

* link:https://github.com/skoussou/servicemesh-playground/tree/main/Scenario-4-Cross-Cluster-Traffic-Management#setup-service-mesh-installation[Setup a ServiceMeshControlPlane (only 1 cluster is required)]
* link:https://github.com/skoussou/servicemesh-playground/tree/main/Scenario-4-Cross-Cluster-Traffic-Management#setup-service-mesh-deployments[Deploy the `rest-greeting-remote` service only]
* Test it with http

	curl -X GET http://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n <istio-system-control-plane-namespace>)/hello/greeting/Stelios	

2. Create a CA Root, Certificate Signing Request, TLS Certificate for hosted service

These instructions are for self-signed certificates however PKI and CA based certs can & should be used in real environemtns

	cd Scenario-MTLS-1-External-Request-Per-Service-Cert

  * Update/Copy & Modify 

	../scripts/certs/app-default.conf

  * Create CA

	../scripts/certs/create-ca-root-certs-keys.sh
	
  * Create CSR, Certificate for the app

	../scripts/certs/create-app-csr-certs-keys.sh 	  <APPLICATION-CERTIFICATE-INFO> <Certificate-Names-Prefix>
	eg. ../scripts/certs/create-app-csr-certs-keys.sh app-default.conf greeting-remote

4. Create secret with certificate in `istio-system`

	oc create -n istio-system secret generic greeting-remote-secret \
	--from-file=tls.key=greeting-remote-app.key \
	--from-file=tls.crt=greeting-remote-app.crt \
	--from-file=ca.crt=ca-root.crt \
	-n istio-system

3. Create/Update `Route` with passthrough TLS termination and https target port (change `name`, `namespace`,`host` according to your configurations if exposing a different service)

	echo "kind: Route
	apiVersion: route.openshift.io/v1
	metadata:
	  name: hello-remote
	  namespace: istio-system
	spec:
	  host: greeting.remote.com
	  to:
	    kind: Service
	    name: istio-ingressgateway
	    weight: 100
	  port:
	    targetPort: https
	  tls:
	    termination: passthrough
	  wildcardPolicy: None" | oc apply -n istio-system -f -

4. Create/Update `Gateway` Configuration for `SIMPLE` TLS (change `name`, `credentialName`,`host` according to your configurations if exposing a different service)

	echo "apiVersion: networking.istio.io/v1alpha3
	kind: Gateway
	metadata:
	  name: rest-greeting-remote-gateway
	spec:
	  selector:
	    istio: ingressgateway
	  servers:
	  - port:
	      number: 8443
	      name: https
	      protocol: HTTPS
	    tls:
	      credentialName: greeting-remote-secret
	      mode: SIMPLE	      
	    hosts:
	    - greeting.remote.com" | oc apply -n greetings-service -f -


== Setup `MUTUAL TLS` Authentication for a Service Mesh included service

5. Create client certificates

	../scripts/certs/create-client-certs-keys.sh  <Certificate-Names-Prefix>
	eg. ../scripts/certs/create-client-certs-keys.sh curl
	
6. Create/Update `Gateway` Configuration for `MUTUAL` TLS (change `name`, `credentialName`,`host` according to your configurations if exposing a different service)

	echo "apiVersion: networking.istio.io/v1alpha3
	kind: Gateway
	metadata:
	  name: rest-greeting-remote-gateway
	spec:
	  selector:
	    istio: ingressgateway
	  servers:
	  - port:
	      number: 8443
	      name: https
	      protocol: HTTPS
	    tls:
	      credentialName: greeting-remote-secret
	      mode: MUTUAL	      
	    hosts:
	    - greeting.remote.com" | oc apply -n greetings-service -f -

7. Call	with MTLS handshake the securted Service Mesh service.

	curl -v -X GET --cacert ca-root.crt --key client.key --cert client.pem https://<ROUTE_URL>	
	eg. curl -v -X GET --cacert ca-root.crt --key curl-client.key --cert curl-client.crt https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	
	curl --cacert ./localCA.pem --cert app-cert.pem --key app-cert.key https://URL





















== ARCHIVE
#!/bin/bash

#generate KEY for CA

#openssl genrsa -des3 -out localCA.key 4096

#openssl req -x509 -config default.conf  -new -nodes -key localCA.key -sha256 -days 1825 -out localCA.pem
echo "LOCALCA can already be here"

# generate certificates with the CA
#openssl genrsa -out app.key 2048
#openssl req -new -config app.conf -passin pass:WebAS -nodes -keyout app.key -out app.csr
openssl req -new -key app.key -out app.csr

#openssl req -x509 -config app.conf -new -key app.key -out app.csr
openssl x509 -req -in app.csr -CA localCA.pem -CAkey localCA.key -CAcreateserial -out app.crt -days 825 -sha256 -extfile app.ext



where app.conf is the same as previous one
default.conf
[ req ]
default_bits = 2048
distinguished_name = req_distinguished_name
prompt = no
[ dn ]
C = Belgium
O = IBM
CN = LOCAL-CA
ST = Brussels
L = Brussels
OU=EU-Lisa
[ req_distinguished_name ]
countryName = BE
stateOrProvinceName = Brussels
localityName = Brussels
organizationName = IBM
commonName = LOCAL-CA
