= Securing Access to Deployments in the ServiceMesh with TLS
:toc:

== Setup `SIMPLE TLS` Authentication for a Service Mesh included service


1. Create Service Mesh & a Service in the mesh

* link:https://github.com/skoussou/servicemesh-playground/tree/main/Scenario-4-Cross-Cluster-Traffic-Management#setup-service-mesh-installation[Setup a ServiceMeshControlPlane (only 1 cluster is required)]
* link:https://github.com/skoussou/servicemesh-playground/tree/main/Scenario-4-Cross-Cluster-Traffic-Management#setup-service-mesh-deployments[Deploy the `rest-greeting-remote` service only]
* Test it with http (OCP `Route` will expose the service on hostname `greeting.remote.com`. If there is no DNS resolution for `greeting.remote.com` add mapping for `greeting.remote.com` to IP of `istio-ingressgateway` in the hosts file of the machine executing the following)

	curl -X GET http://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n <istio-system-control-plane-namespace>)/hello/greeting/Stelios
	Greetings (OCP-48-Cluster) Stelios	

2. Create a CA Root, Certificate Signing Request, TLS Certificate for hosted service

  ** These instructions are for self-signed certificates however PKI and CA based certs can & should be used in real environemtns

	cd Scenario-MTLS-1-External-Request-Per-Service-Cert

  ** Update/Copy & Modify (based on -self-signed- CA org information) `scripts/certs/app-default.conf`

	cd scripts/certs
	vim app-default.conf

  ** Create CA (self-signed)

	create-ca-root-certs-keys.sh
	
  ** Create CSR, Certificate for the app (self-signed)

	create-app-csr-certs-keys.sh 	  <APPLICATION-CERTIFICATE-INFO> <Certificate-Names-Prefix>
	eg. create-app-csr-certs-keys.sh app-default.conf greeting-remote

4. Create secret with certificate in `istio-system`

	oc create -n istio-system secret generic greeting-remote-secret \
	--from-file=tls.key=greeting-remote-app.key \
	--from-file=tls.crt=greeting-remote-app.crt \
	--from-file=ca.crt=ca-root.crt \
	-n istio-system

3. Create/Update `Route` with passthrough TLS termination and https target port (change `name`, `namespace`,`host` according to your configurations if exposing a different service)

  ** *NOTE:* Route can have one of the following configurations. We select passthrough so we can present a certificate at the `istio-ingressgateway` for the specific service host

  *** *passthrough:* - the TLS handshake will be terminated at the next point (service POD) which is the `istio-ingressgateway` when the `Gateway` Object is set with a `credential` name (see below)
  *** *Edge:* - present a certificate (default of the `ingresscontroller` - self-signed)
  *** *ReEncrypt:* will present a certificate set by you on the route itself or the self-signed, and initiate a new TLS origination from the `ingresscontroller` to the destination service / pod (ie. `istio-ingressgateway` for Service Mesh)

	echo "kind: Route
	apiVersion: route.openshift.io/v1
	metadata:
	  name: hello-remote
	  namespace: istio-system
	spec:
	  host: greeting.remote.com
	  to:
	    kind: Service
	    name: istio-ingressgateway
	    weight: 100
	  port:
	    targetPort: https
	  tls:
	    termination: passthrough
	  wildcardPolicy: None" | oc apply -n istio-system -f -

4. Create/Update `Gateway` Configuration for `SIMPLE` TLS (change `name`, `credentialName`,`host` according to your configurations if exposing a different service)

	echo "apiVersion: networking.istio.io/v1alpha3
	kind: Gateway
	metadata:
	  name: rest-greeting-remote-gateway
	spec:
	  selector:
	    istio: ingressgateway
	  servers:
	  - port:
	      number: 8443
	      name: https
	      protocol: HTTPS
	    tls:
	      credentialName: greeting-remote-secret
	      mode: SIMPLE	      
	    hosts:
	    - greeting.remote.com" | oc apply -n greetings-service -f -

5. Test

* The *_non-https-* request will now fail because the `Gateway` resource only exposses _HTTPS_ protocol to the service

	curl -X GET http://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	<body>
	    <div>
	      <h1>Application is not available</h1>
	      <p>The application is currently not serving requests at this endpoint. It may not have been started or is still starting.</p>

	      <div class="alert alert-info">
		<p class="info">
		  Possible reasons you are seeing this page:
		</p>
		<ul>
		  <li>
		    <strong>The host doesn't exist.</strong>
		    Make sure the hostname was typed correctly and that a route matching this hostname exists.
		  </li>
		  <li>
		    <strong>The host exists, but doesn't have a matching path.</strong>
		    Check if the URL path was typed correctly and that the route was created using the desired path.
		  </li>
		  <li>
		    <strong>Route and path matches, but all pods are down.</strong>
		    Make sure that the resources exposed by this route (pods, services, deployment configs, etc) have at least one pod running.
		  </li>
		</ul>
	      </div>
	    </div>
	  </body>
	

* The *_https_* request will fail as it is expected that the client should accept the presented certificate

	curl -X GET https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	curl: (60) SSL certificate problem: unable to get local issuer certificate
	More details here: https://curl.haxx.se/docs/sslcerts.html
	curl failed to verify the legitimacy of the server and therefore could not
	establish a secure connection to it. To learn more about this situation and
	how to fix it, please visit the web page mentioned above.

* The *_https_* request with explicitly ignoring the presented certificate (-k , insecure Allow insecure server connections when using SSL) will succeed

	curl -k -X GET https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	Greetings (OCP-48-Cluster) Stelios


== Setup `MUTUAL TLS` Authentication for a Service Mesh included service

1. Create client certificates

	../scripts/certs/create-client-certs-keys.sh  <Certificate-Names-Prefix>
	eg. ../scripts/certs/create-client-certs-keys.sh curl
	
2. Create/Update `Gateway` Configuration for `MUTUAL` TLS (change `name`, `credentialName`,`host` according to your configurations if exposing a different service)

	echo "apiVersion: networking.istio.io/v1alpha3
	kind: Gateway
	metadata:
	  name: rest-greeting-remote-gateway
	spec:
	  selector:
	    istio: ingressgateway
	  servers:
	  - port:
	      number: 8443
	      name: https
	      protocol: HTTPS
	    tls:
	      credentialName: greeting-remote-secret
	      mode: MUTUAL	      
	    hosts:
	    - greeting.remote.com" | oc apply -n greetings-service -f -


3. Call with `SIMPLE` TLS handshake fails

	curl -k -X GET https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	curl: (56) OpenSSL SSL_read: error:1409445C:SSL routines:ssl3_read_bytes:tlsv13 alert certificate required, errno 0


4. Call	with `MTLS` TLS handshake the securted Service Mesh service.

	curl -v -X GET --cacert ca-root.crt --key client.key --cert client.pem https://<ROUTE_URL>	
	eg. curl -v -X GET --cacert ca-root.crt --key curl-client.key --cert curl-client.crt https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	
	
== Multiple Services `MUTUAL TLS` Authentication Configuration

*Purpose:* Showcase configuration and setup of multiple services secured via `passthrough` OCP `Route` and certificate per service defined in common `Gateway` resource

1. Create New Service certificates

* Once the above has been successful add an additional service	

  ** Update/Copy & Modify (based on -self-signed- CA org information) `scripts/certs/app-default.conf` changing CN, Commonname, DNS.1 to `hello.openshift.com`

	cd scripts/certs
	cp app-default.conf app-hello-openshift.conf 
	
  ** Create CSR, Certificate for the app (self-signed)

	create-app-csr-certs-keys.sh 	  <APPLICATION-CERTIFICATE-INFO> <Certificate-Names-Prefix>
	eg. create-app-csr-certs-keys.sh app-hello-openshift.conf  hello-openshift

* Create secret with the `hello-openshift-app` certificate in `istio-system`

	oc create -n istio-system secret generic hello-openshift-secret \
	--from-file=tls.key=hello-openshift-app.key \
	--from-file=tls.crt=ohello-openshift-app.crt \
	--from-file=ca.crt=ca-root.crt \
	-n istio-system

3.  Deploy the service link:https://github.com/skoussou/servicemesh-playground/tree/main/Scenario-0-Deploy-In-ServiceMesh#hello-openshift[hello-openshift]

* Expose *_https_* for both `rest-greeting-remote` and `hello-openshift` services in a commmon `Gateway` resource against separate certificates  

	echo "apiVersion: networking.istio.io/v1alpha3
	kind: Gateway
	metadata:
	  name: rest-greeting-remote-gateway
	spec:
	  selector:
	    istio: ingressgateway
	  servers:
	  - port:
	      number: 443
	      name: rest-greeting-remote
	      protocol: HTTPS
	    tls:
	      credentialName: greeting-remote-secret
	      mode: MUTUAL      
	    hosts:
	    - greeting.remote.com
	  - port:
	      number: 443
	      name: hello-remote
	      protocol: HTTPS
	    tls:
	      credentialName: hello-openshift-secret
	      mode: MUTUAL      
	    hosts:
	    - hello.openshift.com" | oc apply -n greetings-service -f -    

	
	echo "apiVersion: networking.istio.io/v1beta1
	kind: VirtualService
	metadata:
	  name: hello-openshift
	spec:
	  gateways:
	  - rest-greeting-remote-gateway
	  - mesh
	  hosts:
	  - istio-ingressgateway-istio-system.apps.cluster-9232.9232.sandbox1416.opentlc.com
	  - hello.openshift.com
	  http:
	  - match:
	    - uri:
		exact: /
	    route:
	    - destination:
		host: hello-openshift
		port:
		  number: 8080" | oc apply -n greetings-service -f -


4. Test (using the same client certificate since we are using same CA)

	watch -n 2 curl -v -X GET --cacert ca-root.crt --key curl-client.key --cert curl-client.crt https://hello.openshift.com
	Hello OpenShift!

	watch -n 2 curl -v -X GET --cacert ca-root.crt --key curl-client.key --cert curl-client.crt https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	Greetings (OCP-48-Cluster) Stelios



