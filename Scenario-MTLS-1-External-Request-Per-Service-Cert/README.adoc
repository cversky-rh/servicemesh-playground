= Securing Access to Deployments in the ServiceMesh with TLS
:toc:

== Setup `SIMPLE TLS` Authentication for a Service Mesh included service


1. Create Service Mesh & a Service in the mesh

* link:https://github.com/skoussou/servicemesh-playground/tree/main/Scenario-4-Cross-Cluster-Traffic-Management#setup-service-mesh-installation[Setup a ServiceMeshControlPlane (only 1 cluster is required)]
* link:https://github.com/skoussou/servicemesh-playground/tree/main/Scenario-4-Cross-Cluster-Traffic-Management#setup-service-mesh-deployments[Deploy the `rest-greeting-remote` service only]
* Test it with http (OCP `Route` will expose the service on hostname `greeting.remote.com`. If there is no DNS resolution for `greeting.remote.com` add mapping for `greeting.remote.com` to IP of `istio-ingressgateway` in the hosts file of the machine executing the following)

	curl -X GET http://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n <istio-system-control-plane-namespace>)/hello/greeting/Stelios
	Greetings (OCP-48-Cluster) Stelios	

2. Create a CA Root, Certificate Signing Request, TLS Certificate for hosted service

  ** These instructions are for self-signed certificates however PKI and CA based certs can & should be used in real environemtns

	cd Scenario-MTLS-1-External-Request-Per-Service-Cert

  ** Update/Copy & Modify (based on -self-signed- CA org information) `scripts/certs/app-default.conf`

	cd scripts/certs
	vim app-default.conf

  ** Create CA (self-signed)

	create-ca-root-certs-keys.sh
	
  ** Create CSR, Certificate for the app (self-signed)

	create-app-csr-certs-keys.sh 	  <APPLICATION-CERTIFICATE-INFO> <Certificate-Names-Prefix>
	eg. create-app-csr-certs-keys.sh app-default.conf greeting-remote

4. Create secret with certificate in `istio-system`

	oc create -n istio-system secret generic greeting-remote-secret \
	--from-file=tls.key=greeting-remote-app.key \
	--from-file=tls.crt=greeting-remote-app.crt \
	--from-file=ca.crt=ca-root.crt \
	-n istio-system

3. Create/Update `Route` with passthrough TLS termination and https target port (change `name`, `namespace`,`host` according to your configurations if exposing a different service)

  ** *NOTE:* Route can have one of the following configurations. We select passthrough so we can present a certificate at the `istio-ingressgateway` for the specific service host

  *** *passthrough:* - the TLS handshake will be terminated at the next point (service POD) which is the `istio-ingressgateway` when the `Gateway` Object is set with a `credential` name (see below)
  *** *Edge:* - present a certificate (default of the `ingresscontroller` - self-signed)
  *** *ReEncrypt:* will present a certificate set by you on the route itself or the self-signed, and initiate a new TLS origination from the `ingresscontroller` to the destination service / pod (ie. `istio-ingressgateway` for Service Mesh)

	echo "kind: Route
	apiVersion: route.openshift.io/v1
	metadata:
	  name: hello-remote
	  namespace: istio-system
	spec:
	  host: greeting.remote.com
	  to:
	    kind: Service
	    name: istio-ingressgateway
	    weight: 100
	  port:
	    targetPort: https
	  tls:
	    termination: passthrough
	  wildcardPolicy: None" | oc apply -n istio-system -f -

4. Create/Update `Gateway` Configuration for `SIMPLE` TLS (change `name`, `credentialName`,`host` according to your configurations if exposing a different service)

	echo "apiVersion: networking.istio.io/v1alpha3
	kind: Gateway
	metadata:
	  name: rest-greeting-remote-gateway
	spec:
	  selector:
	    istio: ingressgateway
	  servers:
	  - port:
	      number: 8443
	      name: https
	      protocol: HTTPS
	    tls:
	      credentialName: greeting-remote-secret
	      mode: SIMPLE	      
	    hosts:
	    - greeting.remote.com" | oc apply -n greetings-service -f -

5. Test

* The *_non-https-* request will now fail because the `Gateway` resource only exposses _HTTPS_ protocol to the service

	curl -X GET http://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	<body>
	    <div>
	      <h1>Application is not available</h1>
	      <p>The application is currently not serving requests at this endpoint. It may not have been started or is still starting.</p>

	      <div class="alert alert-info">
		<p class="info">
		  Possible reasons you are seeing this page:
		</p>
		<ul>
		  <li>
		    <strong>The host doesn't exist.</strong>
		    Make sure the hostname was typed correctly and that a route matching this hostname exists.
		  </li>
		  <li>
		    <strong>The host exists, but doesn't have a matching path.</strong>
		    Check if the URL path was typed correctly and that the route was created using the desired path.
		  </li>
		  <li>
		    <strong>Route and path matches, but all pods are down.</strong>
		    Make sure that the resources exposed by this route (pods, services, deployment configs, etc) have at least one pod running.
		  </li>
		</ul>
	      </div>
	    </div>
	  </body>
	

* The *_https_* request will fail as it is expected that the client should accept the presented certificate

	curl -X GET https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	curl: (60) SSL certificate problem: unable to get local issuer certificate
	More details here: https://curl.haxx.se/docs/sslcerts.html
	curl failed to verify the legitimacy of the server and therefore could not
	establish a secure connection to it. To learn more about this situation and
	how to fix it, please visit the web page mentioned above.

* The *_https_* request with explicitly ignoring the presented certificate (-k , insecure Allow insecure server connections when using SSL) will succeed

	curl -k -X GET https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	Greetings (OCP-48-Cluster) Stelios


== Setup `MUTUAL TLS` Authentication for a Service Mesh included service

5. Create client certificates

	../scripts/certs/create-client-certs-keys.sh  <Certificate-Names-Prefix>
	eg. ../scripts/certs/create-client-certs-keys.sh curl
	
6. Create/Update `Gateway` Configuration for `MUTUAL` TLS (change `name`, `credentialName`,`host` according to your configurations if exposing a different service)

	echo "apiVersion: networking.istio.io/v1alpha3
	kind: Gateway
	metadata:
	  name: rest-greeting-remote-gateway
	spec:
	  selector:
	    istio: ingressgateway
	  servers:
	  - port:
	      number: 8443
	      name: https
	      protocol: HTTPS
	    tls:
	      credentialName: greeting-remote-secret
	      mode: MUTUAL	      
	    hosts:
	    - greeting.remote.com" | oc apply -n greetings-service -f -

7. Call	with MTLS handshake the securted Service Mesh service.

	curl -v -X GET --cacert ca-root.crt --key client.key --cert client.pem https://<ROUTE_URL>	
	eg. curl -v -X GET --cacert ca-root.crt --key curl-client.key --cert curl-client.crt https://$(oc get route hello-remote -o jsonpath='{.spec.host}' -n istio-system)/hello/greeting/Stelios
	
	curl --cacert ./localCA.pem --cert app-cert.pem --key app-cert.key https://URL





















== ARCHIVE
#!/bin/bash

#generate KEY for CA

#openssl genrsa -des3 -out localCA.key 4096

#openssl req -x509 -config default.conf  -new -nodes -key localCA.key -sha256 -days 1825 -out localCA.pem
echo "LOCALCA can already be here"

# generate certificates with the CA
#openssl genrsa -out app.key 2048
#openssl req -new -config app.conf -passin pass:WebAS -nodes -keyout app.key -out app.csr
openssl req -new -key app.key -out app.csr

#openssl req -x509 -config app.conf -new -key app.key -out app.csr
openssl x509 -req -in app.csr -CA localCA.pem -CAkey localCA.key -CAcreateserial -out app.crt -days 825 -sha256 -extfile app.ext



where app.conf is the same as previous one
default.conf
[ req ]
default_bits = 2048
distinguished_name = req_distinguished_name
prompt = no
[ dn ]
C = Belgium
O = IBM
CN = LOCAL-CA
ST = Brussels
L = Brussels
OU=EU-Lisa
[ req_distinguished_name ]
countryName = BE
stateOrProvinceName = Brussels
localityName = Brussels
organizationName = IBM
commonName = LOCAL-CA
